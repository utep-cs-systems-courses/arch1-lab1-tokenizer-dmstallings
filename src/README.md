Project 1: Tokenizer
====================
The tokenizer allows the user to enter as many individual strings (one per
iteration), as they wish to be broken into individual words (based on
whitespace characters), and displayed. Additionally, each string entered by
the user is placed in a history which can be displayed at the user's behest.

Makefile
========
The Makefile establishes all of the necessary file dependencies as well as the
compiler flags and optimization. Additionally, it provides commands to compile
the program, compile and run the program, and delete files generated by
compilation. These commands, respectively, are:

     $ make
     $ make run
     $ make clean

uimain
======
Although all of the functions and logic for both the tokenizer and history are
defined in other files, uimain is the portion of the program that the user
interacts with. It utilizes an infinite loop and a series of if-else statments
to call appropriate functions in response to user input.

Tokenizer
=========
Tokenizer must be run from uimain, however, all of its functions are declared
in tokenizer.h and defined in tokenizer.c. These functions are as follows:
   space_char()
   non_space_char()
   *word_start()
   *word_terminator
   count_words
   *copy_str
   **tokenize()
   print_tokens()
   free_tokens

Many of these functions are utilized as tools to simplify and aid in the
construction of other functions. For example, count_words() and *copy_str both
greatly reduce the complexity of the tokenize function. It is also important
to note that the tokenize function dynamically allocates memory and so it is
crucial that free_tokens is utilized to free that memory when the user wishes
to exit the program (This is already implemented and requires no action by the
user).

History
=======
History must be run from uimain, however, all of its functions are declared in
history.h and defined in history.c. These functions are as follows:
    init_history()
    add_history()
    *get_history()
    print_history()
    free_history()

The history function utilizes two structs which create a linked list. The
memory for this list is dynamically allocated, therefore, it must be
deallocated using the free_history function before the user exits the
program (This is already implemented and requires no action by the user).
